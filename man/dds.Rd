% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/dds.r
\name{dds}
\alias{dds}
\title{Dynamically dimensioned search}
\usage{
dds(fn, p, m = 10, r = 0.2, plot = FALSE, ...)
}
\arguments{
\item{fn}{Objective function. This function must accept as its first argument
a named numeric vector of parameters. It must return a named numeric vector
(which can be of length 1). The algorithm attempts to minimize \code{fn}
with respect to the \emph{first element} of its return vector, i.e.
additional elements are fro diagnostic purposes only.}

\item{p}{Data frame with initial values and bounds for all parameters. The
expected column names are 'name', 'initial', 'min', and 'max'.}

\item{m}{Requested number of function evaluations (integer). This is the
only stopping criterion of the algorithm.}

\item{r}{Numeric algorithm parameter (default 0.2). It controls the jump
length during generation of new parameters sets.}

\item{plot}{Logical. It \code{TRUE} the value of \code{fn} (first element
only) is plotted after each evaluation.}

\item{...}{Additional arguments passed to function \code{fn}.}
}
\value{
A list with the following elements
\itemize{
  \item{f_best} Named numeric vector. Value of the objective function at the
    found minimum (with respect to the vector's first element).
  \item{p_best} Named numeric vector. Parameters corresponding to \code{f_best}.
  \item{f_trace} Data frame with \code{m} rows. Holds the 'best' value of
    the objective function for all iterations.
  \item{p_trace} Data frame with \code{m} rows. Holds the 'best' parameters
    for all iterations.
}
}
\description{
An inplementation of the dynamically dimensioned search (DDS) algorithm for
stochastic optimization of computationally expensive objective functions. The
algorithm gradually shifts from global to local search.
}
\examples{
# Fitting coefficients of an ordinary linear model
nobs= 100
obs= data.frame(x=1:nobs, y=1:nobs + (1:nobs)*(runif(nobs)-0.5))
model= function(p, x) { p["slope"] * x + p["intercept"] }
objfun= function(p, obs) { c(sse= sum((obs$y - model(p, obs$x))^2)) }
p= data.frame(
  name=c("slope","intercept"),
  min= c(-1, -50),
  max= c(4, 50),
  initial= 0, 20
)
opt= dds(fn=objfun, p=p, m=250, r=0.2, obs=obs)
layout(matrix(c(1,2,3,4), ncol=2, byrow=TRUE))
plot(obs)
lines(range(obs$x), model(p=opt$p_best, x=range(obs$x)))
# trace of function
plot(0:(nrow(opt$f_trace)-1), opt$f_trace$sse, type="l",
  xlab="iter",ylab="sse")
# trace of pars
plot(0:(nrow(opt$p_trace)-1), opt$p_trace$slope, type="l",
  xlab="iter",ylab="slope")
plot(0:(nrow(opt$p_trace)-1), opt$p_trace$intercept, type="l",
  xlab="iter",ylab="intercept")
layout(matrix(1))
}
\author{
David Kneis \email{david.kneis@tu-dresden.de}
}
\references{
The original algorithm is described in
  Tolson, B. A. and Shoemaker, C. A. (2007): Dynamically
  dimensioned search algorithm for computationally efficient watershed model
  calibration, Water Resources Research, 43, W01413,
  doi:10.1029/2005WR004723.
}

