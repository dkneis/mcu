% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/mcs.r
\name{mcs}
\alias{mcs}
\title{Monte-Carlo simulation}
\usage{
mcs(fn, p, nRuns = 10, silent = TRUE, parallel = FALSE, ...)
}
\arguments{
\item{fn}{Function of interest. It must accept as its first argument
a named numeric vector of parameters. It must return a named numeric vector
(which can be of length 1).}

\item{p}{Data frame specifying ranges and defaults for the varied parameters.
There must be four columns: 'name', 'default', 'min', and 'max'.}

\item{nRuns}{Desired number of parameter samples. The total number of
evaluations of \code{fn} is \code{nRuns} + 1.}

\item{silent}{If \code{TRUE}, diagnostic messages are suppressed.}

\item{parallel}{If \code{TRUE}, parameter sets are processed in parallel if
  supported by the machine. The number of threads is controlled automatically
  (by calling \code{registerDoParallel()} with no arguments).}

\item{...}{Additional arguments passed to function \code{fn}.}
}
\value{
A list of 3 elements. Elements \code{p} and \code{out} are matrices
  with \code{nRuns} + 1 rows. \code{p} holds the tested parameter values
  with column names taken from the 'name' field of \code{ranges}.
  \code{out} holds the return values of \code{fn}. Each row in \code{out}
  corresponds to the same row of \code{p}. In the common case where \code{fn}
  returns a scalar result, \code{out} contains just a single column.
  The first row in both data frames corresponds to the default parameter set.
  The third list element, \code{cpu} is a vector of length \code{nRuns} + 1,
  holding the times spent on the evaluation of \code{fn}.
}
\description{
Performs a Monte-Carlo simulation with parameters sampled from a uniform
distribution using a latin hypercube method.
}
\note{
If \code{fn} generated an error (or a warning) when called with a
  parameter set, the corresponding row in the result matrix \code{out}.
  is set to \code{NA}. The same is true for the corresponding element of
  the returned vector \code{cpu}.
}
\examples{
# Analysis of the residuals' sum of squares for a linear model
obs= data.frame(x=c(1,2), y=c(1,2))
model= function(p, x) { p["slope"] * x + p["intercept"] }
objfun= function(p, obs) { c(sse= sum((obs$y - model(p, obs$x))^2)) }
p= data.frame(
  name=c("slope","intercept"),
  default= c(1, 0),
  min= c(0.5, -1),
  max= c(2, 1)
)
x= mcs(fn=objfun, p=p, obs=obs)
layout(matrix(1:2, ncol=2))
plot(x$p[,"slope"], x$out[,"sse"], xlab="slope", ylab="SSE")
plot(x$p[,"intercept"], x$out[,"sse"], xlab="intercept", ylab="SSE")
layout(matrix(1))
}
\author{
David Kneis \email{david.kneis@tu-dresden.de}
}

